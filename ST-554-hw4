

In a markdown cell, describe what each of the following operators/methods allows you to subset from a data frame (that is, describe all of the types of subsetting you can do with the operator):
• []

You can access the columns using a string of column names

ex: Index(['1st', '2nd'])

You can index the rows by slicing

ex: my_df[3:5]

but you can’t return a single row with just a number, such as my_df[1], you would need to include colon: my_df[1:2]

You can use Boolean object to subset an array including compound Booleans

ex: my_df['Name'] == 'Alice' creates a boolean array showing True just in the 'Alice' row and false everywhere else

ex: my_df[my_df['Age'] > 21] returns only rows that match

• .iloc[] Allows you to access rows by their integer location

this will return a row or rows as a series

ex: my_df.iloc[0] or my_df.iloc[[0,1]]

Allows for subsetting by columns as well

ex: my_df.iloc[[3:6], [0:2]] gives rows (3,4, 5), columns (0,1)

• .loc[] is similar to .iloc but allows for subsetting based on labels or booleans

using labels

ex: my_df2.loc["b":"e"] - includes the last value since this is labels so rows b, c, d, and e are returned

You can use slicing

ex: my_df.loc[2:5] - includes the last value! (again interpreted as labels)

ex: my_df.loc[:3, ['Name', "Major"]] - returns rows 0 to 3 and columns with 'Name', "Major".

You can use Boolean

ex: my_df.loc[my_df['Age'] > 21] ex: my_df.loc[my_df["Age"] > 21, my_df.columns.isin(["Name", "Age"])]

BreastCancer.dat data file available https://www4.stat.ncsu.edu/online/datasets/BreastCancer.dat. Upload this file to your Colab notebook and read it in using a relative file path (just the file name).

a. Save the data as an object called cancer_data.

b. Use the .head() method to look at the data.

c. Return just the grade column using the column attribute

d. Use the .loc[] method to print out all rows where the size is larger than 30.

e. Use the .loc[] method to print out all rows where the size is greater than 30 and the grade is 3.

f. Use [] to return just the age, size, and grade columns.

g. Use .loc[] to return the rows where meno is equal to premenopausal along with the age, size, and grade columns.


[ ]
import pandas as pd

# 2a: save the data
cancer_data = pd.read_csv("https://www4.stat.ncsu.edu/online/datasets/BreastCancer.dat", sep="\t")

# 2b: looking at data
cancer_data.head()

# 2c: Return the grade column
cancer_data.columns
display(cancer_data['grade'])

# 2d: Use the .loc[] method to print out all rows where the size is larger than 30.
cancer_data.loc[cancer_data['size'] > 30]

# 2e: Use the .loc[] method to print out all rows where the size is greater than 30 and the grade is 3.
cancer_data.loc[(cancer_data['size'] > 30) & (cancer_data['grade'] == 3)]

# 2f: Use [] to return just the age, size, and grade columns.
cancer_data[['age', 'size', 'grade']]

# 2g. Use .loc[] to return the rows where meno is equal to premenopausal with the age, size, and grade columns.
cancer_data.loc[cancer_data['meno'] =='premenopausal',["age", "size", "grade"]]

There are two files about mosquitos available at: • https://www4.stat.ncsu.edu/~online/datasets/mosquito.txt • https://www4.stat.ncsu.edu/~online/datasets/mosquito2.txt

a. Determine the delimiter and read in the mosquito.txt file as an object called mosq_data.

b. Similarly, read in the mosquito2.txt file. Note this file doesn’t contain column names! The columns are the same as the other file though. Use an attribute from mosq_data to assign the column names in the function call in which you read in the data. Save this data as an object called mosq_data2.

c. Combine the two datasets into one data frame using the concat() function from pandas (see https://pandas.pydata.org/docs/reference/api/pandas.concat.html)


[ ]
import pandas as pd

# 3a: save the mosquito data
mosq_data = pd.read_csv("https://www4.stat.ncsu.edu/online/datasets/mosquito.txt", sep="&")
mosq_data.info()

# 3b: save the mosquito2 data with the column headings of mosquito data
mosq_data2 = pd.read_csv("https://www4.stat.ncsu.edu/online/datasets/mosquito2.txt", sep="\t", names=mosq_data.columns)
mosq_data2.info()

#3c: combine them using concat()
mosq_data3 = pd.concat([mosq_data, mosq_data2])
mosq_data3.info()

mosq_data
mosq_data2
mosq_data3


Summarizing Data Numerically

Task 1: Read in the data. Check out the first few observations of the data.


[ ]
import pandas as pd

# Read in student data
stud_data = pd.read_csv("https://www4.stat.ncsu.edu/online/datasets/StudentData.txt", sep=";")
stud_data.head()

Task 2: Summarize the Data This data has many categorical variables and a few numeric. You should do the following:

Categorical variables

• Create a one-way contingency table, a two-way contingency table, and a three-way contingency table

– Interpret a number from each resulting table (that is, pick out a value produced and explain what that value means.)

Interpretation: from below

1-way table: the number 208 is the number of female students in the student data file.
2-way table: the number 14 is the number of male students that studied between 5-10 hours weekly
3-way table: the number 96 is the number of female students that study between 2-5 hours weekly and whose parents are living apart

[ ]
# sex is first categorical data
stud_data["sexC"]=stud_data.sex.astype("category")
stud_data.sexC = stud_data.sexC.cat.rename_categories(["Female", "Male"])
stud_data.sexC.value_counts()

# studytime is second categorical data
stud_data["studytimeC"]=stud_data.studytime.astype("category")
stud_data.studytimeC = stud_data.studytimeC.cat.rename_categories(["<2hrs", "2-5hrs", "5-10hrs", ">10hrs"])
stud_data.studytimeC.value_counts()

# Ptatus is third categorical data
stud_data["PstatusC"]=stud_data.Pstatus.astype("category")
stud_data.PstatusC = stud_data.PstatusC.cat.rename_categories(["Together", "Apart"])
stud_data.PstatusC.value_counts()



[ ]
# creating a 2-way contingency table with sex and hours studying
pd.crosstab(
    stud_data.sexC,
    stud_data.studytimeC,
    margins=True
)


[ ]
# creating a 3-way contingency table with sex and hours studying and parental status
my_tab = pd.crosstab(
    [stud_data.sexC,
    stud_data.studytimeC],
    stud_data.PstatusC,
    rownames=["Sex", "Study Time"],
    colnames=["Parent status:"]
)
my_tab

Create a conditional two-way table. That is, condition on one variable’s setting and create a two-way table. Do this using two different methods:

– Once, by subsetting the data (say with .loc) and then creating the two-way table

– Once, by creating a three-way table and subsetting it


[ ]
# subsetting the data using .loc and creating a 2-way table
stud_data.loc[stud_data["sexC"] == "Female",["studytimeC", "PstatusC"]]



[ ]
# create a 3-way table
three_way = pd.crosstab(
    index=stud_data['studytimeC'],
    columns=[stud_data['sexC'], stud_data['PstatusC']], # Added a comma here
    rownames = ["Study Time"],
    colnames = ["Sex", "Parent Status"]
)

# subsetting a 3-way table
three_way['Female']

Numeric variables (and across groups)

The numeric variables are age, absences, and the three test grades variables (G1, G2, and G3).

• Find measures of center and spread for three of these variables (including G3 as one of them)


[ ]
# full suite of measurements
stud_data[["age", "absences", "G3"]].describe()

stud_data[["age", "absences", "G3"]].describe().loc[["mean", "std"]]

– Repeat while subsetting the data by some grouping variable (say with .loc)


[ ]
# subsetting on those that want to go to college
stud_data.loc[stud_data['higher'] =="yes", ['age', 'absences','G3']].describe().loc[['mean', 'std']]

# subsetting on those that don't want to go to college (just curious)
stud_data.loc[stud_data['higher'] =="no", ['age', 'absences','G3']].describe().loc[['mean', 'std']]

• Find measures of center and spread across a single grouping variable for three of these variables (including G3 as one of them)


[ ]
# grouping by sex and getting mean and std of G3, age, and abscences
stud_data.groupby("sexC")[["G3", "age", "absences"]].agg(['mean', 'std'])

• Find measures of center and spread across two grouping variables for three of these variables (including G3 as one of them)


[ ]
# grouping by sex and study time and getting mean and std of G3, age, and abscences
stud_data.groupby(["sexC", "studytimeC"])[["G3", "age", "absences"]].agg(['mean', 'std'])

Create a correlation matrix between all of the numeric variables

[ ]
# Correlation matrix
stud_data[["age", "absences", "G1", "G2", "G3"]].corr()


Colab paid products - Cancel contracts here
